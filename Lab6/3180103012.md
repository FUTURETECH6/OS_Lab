<center><font size=7>《操作系统》Lab6</font></center><br /><div align='right'><font size=4><b>陈希尧</b> 3180103012</font><br /><div align='right'><font size=4>Group17</font></div>

[TOC]

# Lab Basis

## Purpose



## Environment

OS: Ubuntu 18.04.5 LTS on Windows 10 x86_64 (WSL2)

Kernel: 4.19.128-microsoft-standard

Docker version 19.03.13

## Lab Principle

### New Register

#### medeleg

medeleg has a bit position allocated for every synchronous exception shown in Table 3.6 on page 40, with the index of the bit position equal to the value returned in the mcause register (i.e., setting bit 8 allows user-mode environment calls to be delegated to a lower-privilege trap handler).

#### mscratch

The mscratch register is an MXLEN-bit read/write register dedicated for use by machine mode. Typically, it is used to hold a pointer to a machine-mode hart-local context space and swapped with a user register upon entry to an M-mode trap handler.

### New Instructions

* csrrw rd, csr, zimm[4:0]
    * t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t
    * 读后写控制状态寄存器 (Control and Status Register Read and Write). I-type, RV32I and RV64I. 记控制状态寄存器 csr 中的值为 t。把寄存器 x[rs1]的值写入 csr，再把 t 写入 x[rd]。
* auipc rd, immediate
    * x[rd] = pc + sext(immediate[31:12] << 12)
    * PC 加立即数 (Add Upper Immediate to PC). U-type, RV32I and RV64I.
    * 把符号位扩展的 20 位（左移 12 位）立即数加到 pc 上，结果写入 x[rd]。
* sfence.vma rs1, rs2
    * Fence(Store, AddressTranslation)
    * 虚拟内存屏障(Fence Virtual Memory). R-type, RV32I and RV64I 特权指令。
    * 根据后续的虚拟地址翻译对之前的页表存入进行排序。当 rs2=0 时，所有地址空间的翻译都 会受到影响；否则，仅对 x[rs2]标识的地址空间的翻译进行排序。当 rs1=0 时，对所选地址 空间中的所有虚拟地址的翻译进行排序；否则，仅对其中包含虚拟地址 x[rs1]的页面地址翻 译进行排序。
* addiw rd, rs1, immediate
    * x[rd] = sext((x[rs1] + sext(immediate))[31:0])
    * 加立即数字(Add Word Immediate). I-type, RV64I.
    * 把符号位扩展的立即数加到 x[rs1]，将结果截断为 32 位，把符号位扩展的结果写入 x[rd]。
        忽略算术溢出。



# Lab Steps

## Lab Env

```zsh
$ docker run --name lab6 -it -v /mnt/c/Users/Ulysses/OneDrive/Jun_A/OS/Lab/Lab6/lab6_3180103012:/home/oslab/lab6 -u oslab -w /home/oslab/lab6 oslab:2020 /bin/bash
$ docker start lab6
$ docker exec -it -u oslab -w /home/oslab/lab6 lab6 bash
oslab@895a42d4c502:~/lab6$ ln -s ~/lab6/.gdbinit ~/.gdbinit
oslab@895a42d4c502:~/lab6$ sed -i '$aalias md=make\\ \\&\\&\\ make\\ debug' ~/.bashrc
oslab@895a42d4c502:~/lab6$ sed -i '$aalias gdb=/opt/riscv/bin/riscv64-unknown-linux-gnu-gdb' ~/.bashrc
oslab@895a42d4c502:~/lab6$ sed -i '$aalias gv=/opt/riscv/bin/riscv64-unknown-linux-gnu-gdb\\ vmlinux' ~/.bashrc
```

## Manual

[oslab20fall - Wiki - Gitee.com](https://gitee.com/zjuicsr/lab20fall-stu/wikis/lab5)

## Implementation



# Lab Results

**文件结构**

```

```

**运行结果**

\* 用户程序循环次数为50000000，计时器中断间隔为1000000

**SJF**



**PRIORITY**





# Problems & Thoughts

## Debug Logs

### 内核部分

1. 本来写了一个buddy，想拿去测一下lab5能不能跑，搞了半天一直跑不起来，后来发现alloc_pages里面的返回值写的是
   

### 用户态测试程序

#### 编译问题

无法编译user code，会得到一个奇怪的东西

![](assets/image-20201229162534060.png)

一开始我以为是CF的问题，因为助教没有提供CF，但是当我用自己的CF替代新的commit中的CF时也能正常编译，后来我发现是link.ld的问题：

```
ENTRY(_start)

SECTIONS
{
    . = 0x0;
    _start = .;
    .text.init : { *(.text.init) }
    .text : { *(.text) }
    .data : { *(.data) }
}
```

是不行的，要改成：

```
ENTRY(_start)

SECTIONS
{
    . = 0x0;
    _start = .;
    .text.init : { KEEP(*(.text.init)) }
    .text : { KEEP(*(.text)) }
    .data : { KEEP(*(.data)) }
}
```

根据查阅的[资料](https://stackoverflow.com/questions/9827157/what-does-keep-mean-in-a-linker-script/)，"Usually used for sections that have some special meaning in the binary startup process, more or less to mark the roots of the dependency tree."，这就类似于gdb中的"set breakpoint pending on"，没有开的话在编译obj时符号本obj里没用到的函数就直接丢失了，自然没法正常编译。

#### 汇编中迭代次数的问题

在实验中我发现用户态程序的两次输出之间会隔很久（约10s）

main的c语言实现：

```c
int main() {
    while (1) {
        printf("[User] pid: %ld, sp is %lx\n", getpid(), current_sp);
        for (unsigned int i = 0; i < 0xFFFFFFFF; i++)
            ;
    }
    return 0;
}
```

可见它会在输出当前的pid和sp后通过循环0xFFFFFFFF次起到一个类似于sleep的作用，使得输出是肉眼可见的

反汇编hello.bin的部分结果：

```assembly
0000000000000004 <main>:
   4:	fd010113          	addi	sp,sp,-48
   8:	02113423          	sd	ra,40(sp)
   c:	02813023          	sd	s0,32(sp)
  10:	00913c23          	sd	s1,24(sp)
  14:	01213823          	sd	s2,16(sp)
  18:	01313423          	sd	s3,8(sp)
  1c:	00010993          	mv	s3,sp
  20:	00000917          	auipc	s2,0x0
  24:	3b890913          	addi	s2,s2,952 # 3d8 <printf+0x358>
  28:	fff00493          	li	s1,-1
  2c:	0ac00893          	li	a7,172
  30:	00000073          	ecall
  34:	00050413          	mv	s0,a0
  38:	00098613          	mv	a2,s3
  3c:	00040593          	mv	a1,s0
  40:	00090513          	mv	a0,s2
  44:	03c000ef          	jal	ra,80 <printf>
  48:	00048793          	mv	a5,s1
  4c:	fff7879b          	addiw	a5,a5,-1
  50:	fe079ee3          	bnez	a5,4c <main+0x48>
  54:	fd9ff06f          	j	2c <main+0x28>
```

可见，通过`li s1, -1`会将for循环次数赋值给s1，然后再将其赋给a5，a5将起到i的作用，循环s1次，但在实际中gdb会发现s1的值并不为0xFFFFFFFF

![](assets/image-20201229154224282.png)

猜想是因为编译时将s1认作了32位寄存器。

尝试自己编译user test program（commit \#786e01c），结果相同。

后来发现使用的是addiw，会进行32位截断，因此实际上ok的。

<!--## Thoughts-->

<!--累了，不写了，就看上面吧。-->



# Appendix

## Reference

[Special sections in Linux binaries - LWN.net](https://lwn.net/Articles/531148/)

[The RISC-V Instruction Set Manual, Volume II: Privileged Architecture | Five EmbedDev](http://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sv32algorithm)

[ld - What does KEEP mean in a linker script? - Stack Overflow](https://stackoverflow.com/questions/9827157/what-does-keep-mean-in-a-linker-script/)

## Code

### Makefile_top

```makefile
export TOP=$(shell pwd)
export RISCV=/opt/riscv
export PATH:=${PATH}:${RISCV}/bin

export
CROSS_=riscv64-unknown-elf-
AR=${CROSS_}ar
CC=${CROSS_}gcc
LD=${CROSS_}ld
OBJCOPY=${CROSS_}objcopy
OBJDUMP=${CROSS_}objdump
READELF=${CROSS_}readelf

ISA ?= rv64imafd
ABI ?= lp64

INCLUDE = -I ${TOP}/include/ -I ${TOP}/arch/riscv/include/
CF = -march=$(ISA) -mabi=$(ABI) -mcmodel=medany -ffunction-sections -fdata-sections -nostartfiles -nostdlib -nostdinc -static -lgcc -Wl,--nmagic -Wl,--gc-sections -g
# CFLAG = ${CF} ${INCLUDE} -D SJF
CFLAG = ${CF} ${INCLUDE} -D PRIORITY

.PHONY: all user kernel dasm run debug clean


all: user kernel dasm


user:
	@make -C ${TOP}/user/
	@echo "\e[35mBuild User Program Successfully\e[0m"


kernel:
	@make -C ${TOP}/lib/
	@make -C ${TOP}/init/
	@make -C ${TOP}/arch/riscv/kernel/
	@make -C ${TOP}/arch/riscv/
	@echo "\e[35mBuild Kernel Successfully\e[0m"


dasm: ${TOP}/misc/dasm.S ${TOP}/misc/vmlinux_section.txt ${TOP}/misc/hello_dasm.S ${TOP}/misc/hello_section.txt
	@echo "\e[35mDisassemble Successfully\e[0m"
${TOP}/misc/dasm.S: ${TOP}/vmlinux
	${OBJDUMP} -S ${TOP}/vmlinux > ${TOP}/misc/dasm.S
${TOP}/misc/vmlinux_section.txt: ${TOP}/vmlinux
	${READELF} -S ${TOP}/vmlinux > ${TOP}/misc/vmlinux_section.txt
${TOP}/misc/hello_dasm.S: ${TOP}/user/hello.elf
	${OBJDUMP} -S ${TOP}/user/hello.elf > ${TOP}/misc/hello_dasm.S
${TOP}/misc/hello_section.txt: ${TOP}/user/hello.elf
	${READELF} -S ${TOP}/user/hello.elf > ${TOP}/misc/hello_section.txt


run: user kernel dasm
	qemu-system-riscv64 -nographic -machine virt -kernel vmlinux -initrd ./user/hello.bin
	@echo "\e[32mRun Successfully\e[0m"


debug: user kernel dasm
	@echo "\e[32mStart Debugging\e[0m"
	qemu-system-riscv64 -nographic -machine virt -kernel vmlinux -initrd ./user/hello.bin -S -s
	@echo "\e[32mEnd Debugging\e[0m"


clean:
	@rm -f ${TOP}/vmlinux ${TOP}/System.map ${TOP}/a.out
	@make -C ${TOP}/arch/riscv/ clean
	@make -C ${TOP}/arch/riscv/kernel/ clean
	@make -C ${TOP}/init/ clean
	@make -C ${TOP}/lib/ clean
	@make -C ${TOP}/user/ clean
	@echo "\e[36mClean Successfully\e[0m"
```

