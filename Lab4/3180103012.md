<center><font size=7>《操作系统》Lab4</font></center><br /><div align='right'><font size=4><b>陈希尧</b> 3180103012</font><br /><div align='right'><font size=4>Group17</font></div>

[TOC]

# Lab Basis

## Purpose

结合课堂学习的页式内存管理以及虚拟内存的相关知识，尝试在已有的程序上开启 MMU 并实现页映射，保证之前的进程调度能在虚拟内存下正常运行

## Environment

OS: Ubuntu 18.04.5 LTS on Windows 10 x86_64 (WSL2)

Kernel: 4.19.128-microsoft-standard

Docker version 19.03.13

## Lab Principle

### 3.1 虚拟内存
&emsp;&emsp;MMU（Memory Management Unit），负责`虚拟地址`到`物理地址`的转换。程序在cpu上运行时，他使用的虚拟地址会由MMU进行翻译。为了加速地址翻译的过程，现代cpu都引入了TLB（Translation Lookaside Buffer）。
&emsp;&emsp;分页机制的基本思想是将程序的虚拟地址空间划分为连续的，等长的虚拟页。`虚拟页和物理页的页长固定且相等`（一般情况下为4kb），从而操作系统可以方便的为每个程序构造页表，即虚拟页到物理页的映射关系。
&emsp;&emsp;逻辑上，该机制下的虚拟地址有两个部分组成：`1.虚拟页号`；`2.页内偏移`；在具体的翻译过程中，MMU首先解析得到虚拟地址中的虚拟页号，并通过虚拟页号查找到对应的物理页，最终用该物理页的起始地址加上页内偏移得到最终的物理地址。
### 3.2 RISC-V Virtual-Memory System (Sv39)
#### 3.2.1 RISC-V satp Register（Supervisor Address Translation and Protection Register）
```c
 63      60 59                  44 43                                0
 ---------------------------------------------------------------------
|   MODE   |         ASID         |                PPN                |
 ---------------------------------------------------------------------
```
* MODE 字段的取值如下图：
```c
                             RV 64
     ----------------------------------------------------------
    |  Value  |  Name  |  Description                          |
    |----------------------------------------------------------|
    |    0    | Bare   | No translation or protection          |
    |  1 - 7  | ---    | Reserved for standard use             |
    |    8    | Sv39   | Page-based 39 bit virtual addressing  | <-- 我们使用的mode
    |    9    | Sv48   | Page-based 48 bit virtual addressing  |
    |    10   | Sv57   | Page-based 57 bit virtual addressing  |
    |    11   | Sv64   | Page-based 64 bit virtual addressing  |
    | 12 - 13 | ---    | Reserved for standard use             |
    | 14 - 15 | ---    | Reserved for standard use             |
     -----------------------------------------------------------
```
* ASID (Address Space Identifier) ： 用来区分不同的地址空间，此次实验中直接置0即可。
* PPN (Physical Page Number) ：顶级页表的物理页号，通常 `PPN = physical address >> 12`。
#### 3.2.2 RISC-V Sv39 Virtual Address and Physical Address
```c
     38        30 29        21 20        12 11                           0
     ---------------------------------------------------------------------
    |   VPN[2]   |   VPN[1]   |   VPN[0]   |          page offset         |
     ---------------------------------------------------------------------
                            Sv39 virtual address

```

```c
 55                30 29        21 20        12 11                           0
 -----------------------------------------------------------------------------
|       PPN[2]       |   PPN[1]   |   PPN[0]   |          page offset         |
 -----------------------------------------------------------------------------
                            Sv39 physical address

```
&emsp;&emsp;Sv39模式定义物理地址有56位，虚拟地址有64位。但是，虚拟地址的64位只有39位有效，63-39位在本次实验中（高地址映射）需要为1保证地址有效。Sv39支持三级页表结构，VPN[2-0](Virtual Page Number)分别代表每级页表的`虚拟页号`，PPN[2-0](Physical Page Number)分别代表每级页表的`物理页号`。物理地址和虚拟地址的低12位表示页内偏移（page offset）。


#### 3.2.3 RISC-V Sv39 Page Table Entry
```c
 63      54 53        28 27        19 18        10 9   8 7 6 5 4 3 2 1 0
 -----------------------------------------------------------------------
| Reserved |   PPN[2]   |   PPN[1]   |   PPN[0]   | RSW |D|A|G|U|X|W|R|V| 
 -----------------------------------------------------------------------
                                                     |   | | | | | | | |
                                                     |   | | | | | | | `---- V - Valid
                                                     |   | | | | | | `------ R - Readable
                                                     |   | | | | | `-------- W - Writable
                                                     |   | | | | `---------- X - Executable
                                                     |   | | | `------------ U - User
                                                     |   | | `-------------- G - Global
                                                     |   | `---------------- A - Accessed
                                                     |   `------------------ D - Dirty (0 in page directory)
                                                     `---------------------- Reserved for supervisor software
```

* 0 ～ 9 bit: protection bits
    * V: 有效位，当 V = 0, 访问该PTE会产生Pagefault。
    * R: R = 1 该页可读。
    * W: W = 1 该页可写。
    * X: X = 1 该页可执行。
    * U,G,A,D,RSW本次实验中设置为0即可。

#### 3.2.4 RISC-V Address Translation Details

```text

                              9          9       9        12
            +------------+----------+--------+--------+---------+
        VA  |  Sig Ext   |   VPN[2] | VPN[1] | VPN[0] | Offset  |+-----------------------------+
            +------------+----+-----+----+---+----+---+---------+                              |
                              |          |        |                                            |
  +---------------------------+          |        |                                            v
  |                        +-------------+        +-+                           +-----------+------+
  |  +-----------+------+  |                        |                       PA  |    PPN    |offset|
  |  |           |      |  |  +-----------+------+  |                           +-----------+------+
  |  +-----------+------+  |  |           |      |  |  +-----------+------+           ^
  |  |       ...        |  |  +-----------+------+  |  |           |      |     +-----|-----+------+
  |  +-----------+------+  |  |       ...        |  |  +-----------+------+     |     |     |      | 512
  +->|    PPN    | PROT |  |  +-----------+------+  |  |       ...        |     +-----|-----+------+
     +-----+------------+  +->|    PPN    | PROT |  |  +-----------+------+     |     | ...        | ...
     |     |     |      |     +-----+------------+  +->|    PPN    | PROT |     +-----+-----+------+
+--->+-----|-----+------+     |     |     |      |     +-----+------------+     |    PPN    | PROT |  1
|          +----------------->+-----|-----+------+     |     |     |      |     +------------------+
|    +------------------+           +----------------->+-----|-----+------+     |           |      |  0
+----+       satp       |                                    +----------------->+-----------+------+
     +------------------+                                                             44       10
```

* 1.从satp的`PPN`中获取根页表的物理地址。
* 2.通过pagetable中的VPN段,获取PTE。(可以把pagetable看成一个数组，VPN看成下标。PAGE_SIZE为4KB，PTE为64bit(8B), 所以一页中有4KB/8B=512个PTE，而每级VPN刚好有9位，与512个PTE一一对应)。
* 3.检查PTE的 `V bit`，如果不合法，应该产生page fault异常。
* 4.检查PTE的`RWX`bits,如果全部为0，则从PTE中的PPN[2-0]得到的是下一级页表的物理地址，则回到第二步。否则当前为最后一级页表，PPN[2-0]得到的是最终物理页的地址。
* 5.将得到最终的物理页地址，与偏移地址相加，得到最终的物理地址。
(以上为简要的地址翻译过程，完整过程[参考这里](http://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sv32algorithm))

# Lab Steps

## Lab Env

```zsh
$ docker run --name lab4 -it -v /mnt/c/Users/Ulysses/OneDrive/Jun_A/OS/Lab/Lab4/lab4_3180103012:/home/oslab/lab4 -u oslab -w /home/oslab/lab4 oslab:2020 /bin/bash
$ docker start lab4
$ docker exec -it -u oslab -w /home/oslab/lab4 lab4 bash
oslab@10a3bea4265b:~/lab4$ ln -s ~/lab4/.gdbinit ~/.gdbinit
oslab@10a3bea4265b:~/lab4$ sed -i '$a\\nalias gdb=/opt/riscv/bin/riscv64-unknown-linux-gnu-gdb' ~/.bashrc
```

## Code

### Trap

修改中断处理程序，将也[m|s]epc也压栈（由于我在Lab2中已实现，因此此处不再修改）：

```assembly
csrr t0, sepc
sd t0, 0(sp)

# ...

ld t0, 0(sp)
csrw sepc, t0

# mepc同理
```

这是因为后面的thread_init函数要修改sepc，所以这里必须保护一次

### task_init

对于每个task，设置地址、状态、计数器、优先级、不阻塞、pid，其中内存结构如下：

```
---------------------------------------------------------------------------
|             |   Task0   |   Task1   |   Task2   |   Task3   |   Task4   |
|   Kernel    |           |           |           |           |           |
|             |   Space   |   Space   |   Space   |   Space   |   Space   |
---------------------------------------------------------------------------
^             ^           ^           ^           ^           ^
0x80000000    0x80010000  0x80011000  0x80012000  0x80013000  0x80014000
```

对于所有进程，优先级都先设置为5，计数器值SJF和PRIORITY分别用`rand()`和`8-i`，如下：

```c
task[i]           = (struct task_struct *)(long)(TASK_BASE + TASK_SIZE * i);
task[i]->state    = TASK_RUNNING;
task[i]->counter  = i == 0 ? 0 : (PREEMPT_ENABLE ? 8 - i : rand());
task[i]->priority = 5;
task[i]->blocked  = 0;
task[i]->pid      = i;
```

然后设置每个thread信息种的sp和ra，其中sp设为下一个task的地址-1，ra设置为thread_init函数的地址，如下：

```c
task[i]->thread.sp = TASK_BASE + TASK_SIZE * (i + 1) - 0x1;
asm("la t0, thread_init");
asm("sd t0, %0" ::"m"(task[i]->thread.ra));
```

thread_init函数(S Mode)将dead_loop的函数位置传给sepc，然后调用sret回到U Mode，实现如下：

```assembly
.global thread_init
thread_init:
    la t0, dead_loop
    csrw sepc, t0
    sret
```

### do_timer

对于非抢占式调度，先将当前task的cnt减一，然后看是否还有剩余时间，没有了就进入schedule进行进程调度：

```c
current->counter--;
if (current->counter <= 0)
    schedule();
```

对于抢占式调度，同样先将task的cnt减一，然后如果当前进程无时间片剩余，就重置该进程，然后无论如何都得进入schedule来调度（因为是抢占式的），如下：

```c
current->counter--;
if (current->counter <= 0)
    current->counter = (current->pid == 0) ? 5 : 8 - current->pid;
schedule();
```

### schedule

#### SJF

当需要进行调度时按照一下规则进行调度：

* 遍历进程指针数组`task`，从`LAST_TASK`至`FIRST_TASK`(不包括`FIRST_TASK`，即Task[0])，在所有运行状态(TASK_RUNNING)下的进程运行剩余时间`最小`的进程作为下一个执行的进程。
* 如果所有运行状态下的进程运行剩余时间都为0，则对这些进程的运行剩余时间重新随机赋值（`以模拟有新的不同运行时间长度的任务生成`），之后再重新进行调度。

使用`i_min_cnt`存储不为0的计数器最小的进程号，布尔量`all_zeroes`记录是否全部为0，实现如下：

```c
int i_min_cnt    = LAB_TEST_NUM;  // index of min but not zero counter
_Bool all_zeroes = 1;
for (int i = LAB_TEST_NUM; i > 0; i--)
    if (task[i]->state == TASK_RUNNING) {
        if (task[i]->counter > 0 && task[i]->counter < task[i_min_cnt]->counter ||
            task[i_min_cnt]->counter == 0)
            i_min_cnt = i;
        if (task[i]->counter > 0)  // In case of negative cnt
            all_zeroes = 0;
    }
if (all_zeroes) {
    for (int i = 1; i <= LAB_TEST_NUM; i++)
        if (task[i]->state == TASK_RUNNING)
            task[i]->counter = rand();
    schedule();
} else
    switch_to(task[i_min_cnt]);
```

#### PRIORITY

* 遍历进程指针数组`task`，从`LAST_TASK`至`FIRST_TASK`(不包括`FIRST_TASK`)，调度规则如下：
    * `高优先级`的进程，优先被运行。
    * `优先级相同`，则选择`运行剩余时间少`的进程（若运行剩余时间也相同，则遍历的顺序优先选择）。
* 每次schedule，实现随机更新Task[1-4]进程的priority = rand()（``模拟动态优先级变化``）

用`max_pri`存储最高的优先级的值（注意，是值越小优先级越高），`i_min_cnt`存储优先级最高，运行剩余时间最少的进程的pid，实现如下：

```c
int max_pri = __INT_MAX__, i_min_cnt = 1;
for (int i = 1; i <= LAB_TEST_NUM; i++)
    if (task[i]->state == TASK_RUNNING)
        if (task[i]->priority < max_pri) {
            i_min_cnt = i;
            max_pri   = task[i]->priority;
        } else if (task[i]->priority == max_pri &&
                   task[i]->counter < task[i_min_cnt]->counter && task[i]->counter > 0)
            i_min_cnt = i;

// Use another loop to update prio
for (int i = 1; i <= LAB_TEST_NUM; i++)
    if (task[i]->state == TASK_RUNNING)
        task[i]->priority = rand();

switch_to(task[i_min_cnt]);
```

### switch_to

切换进程，CONTEXT_SAVE和CONTEXT_LOAD用宏实现了，需要注意的几点

1. GCC参数-O0时，load会用a5来存current，而-O3时会用s0来存，load s0之后直接被覆盖掉，所以不能开编译器优化
2. sp的恢复要在context switch前面进行
3. 不能使用`CONTEXT_LOAD(next);`，因为next是栈传参进来的，然后用s0存着的，这样会遇到和1一样的问题
4. 不能用GCC产生的`return;`，因为这个语句包括了ra和s0的栈恢复，这会让ra和s0的context switch白给，在return之前应该直接ret

```c
/**
 * @brief context switch from current to next
 */
void switch_to(struct task_struct *next) {
    if (current == next)
        return;

    asm("addi sp, sp, 32");  // Restore the stack of switch_to
    CONTEXT_SAVE(current);   // Do context save
    current = next;          // `next` in $s0(-O0), will be overwrite soon
    CONTEXT_LOAD(current);   // This `current` is the argv `next`
    asm("ret");
}
```

### Top Level

修改Makefile，使用-D参数决定使用哪种调度方式

```makefile
CFLAG = ${CF} ${INCLUDE} -g -D SJF
```

修改sched.c，根据定义好的`SJF`或`PRIORITY`定义`PREEMPT_ENABLE`，实现两种方法的互斥性，避免直接`SJF`和`PRIORITY`都定义的情况下使得程序同时使用两种方法造成的错误

```c
// Ensure Mutual Exclusion
#ifdef SJF
#define PREEMPT_ENABLE 0
#else
#ifdef PRIORITY
#define PREEMPT_ENABLE 1
#endif
#endif

#define PREEMPT_DISABLE !PREEMPT_ENABLE
```

## Debug

补充一些新的指令：

```
layout src
b sched:73

p /d 0x200bff8
p /d 0x2004000

p /d task[0]->thread.ra
p /d task[1]->thread.ra
p /d task[2]->thread.ra
p /d task[3]->thread.ra
p /d task[4]->thread.ra

p /d task[0]->thread.sp
p /d task[1]->thread.sp
p /d task[2]->thread.sp
p /d task[3]->thread.sp
p /d task[4]->thread.sp

p /d task[0]->counter
p /d task[1]->counter
p /d task[2]->counter
p /d task[3]->counter
p /d task[4]->counter
```

# Lab Results

## Program

### SJF

![](assets/image-20201109132633353.png)

如图，由于随机种子是给定的，因此产生的随机数也是给定的，因此调度结果和实验手册上的完全一样

### PRIORITY

![](assets/image-20201109150554783.png)

同理，和实验手册给出的输出相同

# Problems & Thoughts


## Problems(Debug)

1. 由于`TASK_RUNNING`是0，因此没分配空间的其他task们的state基本上都是0，所以遍历的时候不能64个全部遍历，只能遍历有分配内存的那几个。

2. 本来用两个函数把context switch的东西放进去，结果后来`context_load`会有越界访问，debug发现是因为参数`pTask`是存在s0里的，这样搞会直接把pTask的值改掉。改成使用宏函数可解决问题。

3. 原本没写`ra, sp, s0~s11`的contex switch部分，能够正常输出，写了之后变成会一直重复输出"ZJU OS LAB 3"和"task init..."。

4. 猜测是因为没有初始化`task[]->thread`中内容，尝试在task_init之后加一次`context_save`，但是出现了pc越界的情况，后来发现是sp的问题，由于sp的改变，从栈中恢复的ra是错误的，因此ret回到错误的地方。
    * 若load和save忽略掉sp，则程序是正常的，因此确定了是sp的问题造成的。
    * 因此手动用汇编写了个`sp+=32; ret;`放在`switch_to`结束之前。但是SJF又回到了重复输出"ZJU OS LAB 3"和"task init..."的状态。
    
5. switch_to中打印的时候调用的puts会因为ra已经被修改了所以出错，重复打印

    * context_save放在打印的前面，context_load放在打印的后面

6. ecall要在do_timer前面被调用，不然一次contex switch之后ecall还没调用就进入了dead_loop，计时器和mie等不会被正确设置

7. mie.mtie在第一次ecall可以被正常置位，因此第二次还能进入trap_m_timer，但是不能第二次进入trap_s了

    * switch_to里要sret不能ret。。。

8. vmlinux.lds中的stack_top要改成task[0]的栈顶的位置，用`. += 0xffff; stack_top = .;`不知道为什么不行，得直接`stack_top = 0x8000ffff;`

9. 出现了0+0x07的mcuase导致的中断，经查询是"Store/AMO access fault"的错误

    * ecall放在call do_timer前面，不然来不及将sp加回去就跳到死循环了，这样sp会一直减直到爆掉

10. SJF中：`(gdb) p \x task[2]->counter $1 = 0x800000`不知道被什么覆盖了

    * 跟踪发现：do_timer, schedule, switch_to, thread_init都是没问题的，但是第二次时钟中断进入trap_m就变成了`p /x task[2]->counter $30 = 0x1700000000000000`（这值在gdb用c和用n+s单步调试的时候还不一样）

11. 最后改了一个地方解决了所有问题：

     * 原本的switch_to：

         ```c
         CONTEXT_SAVE(current);   // Do context save
         current = next;          // `next` in $s0(-O0), will be overwrite soon
         CONTEXT_LOAD(current);   // This `current` is the argv `next`
         asm("addi sp, sp, 32");  // Restore the stack of switch_to
         ```

     * 后来的switch_to：

         ```c
         asm("addi sp, sp, 32");  // Restore the stack of switch_to
         CONTEXT_SAVE(current);   // Do context save
         current = next;          // `next` in $s0(-O0), will be overwrite soon
         CONTEXT_LOAD(current);   // This `current` is the argv `next`
         ```

     * 确实应该在save之前做sp的恢复，不然加的那个实际上就是下一个task的sp了，这也是为什么10中的counter会被覆盖掉，因为在task[i-1].sp上加上32就会跑到task[i]的栈空间去，把存在那里的东西给修改掉

## Thoughts

总之就是很烦，c和asm混着写，然后gcc的行为又是不可控的（比如得用反汇编的结果去反推`switch_to`中栈是32字节的、next是用s0存的这样的细节），因此给实验带来了很大的困难。正因如此context switch的实现变得很困难，而算法本身相比起来倒是显得很简单。

# Appendix

## Reference

[assembly - Context saving – how to read segment registers in C and instruction pointer? - Stack Overflow](https://stackoverflow.com/questions/54488861/context-saving-how-to-read-segment-registers-in-c-and-instruction-pointer)

## Code

### sched.c

```c
/**
 * @file sched.c
 * @author Scott Chen
 * @brief the scheduler implementation of oslab3
 * @version 0.1
 * @date 2020-11-05
 * @ref https://gitee.com/zjuicsr/lab20fall-stu/wikis/lab3
 */
#include "sched.h"
#include "put.h"
#include "rand.h"

struct task_struct *current;
struct task_struct *task[NR_TASKS];

/**
 * @brief init tasks, create 4 threads running dead-loop
 */
void task_init(void) {
    current = (struct task_struct *)TASK_BASE;
    for (int i = 0; i <= LAB_TEST_NUM; i++) {
        task[i]           = (struct task_struct *)(long)(TASK_BASE + TASK_SIZE * i);
        task[i]->state    = TASK_RUNNING;
        task[i]->counter  = i == 0 ? 0 : (PREEMPT_ENABLE ? 8 - i : rand());
        task[i]->priority = 5;
        task[i]->blocked  = 0;
        task[i]->pid      = i;

        task[i]->thread.sp = TASK_BASE + TASK_SIZE * (i + 1) - 0x1;
        asm("la t0, thread_init");
        asm("sd t0, %0" ::"m"(task[i]->thread.ra));

        if (i != 0) {
            puts("[PID = ");
            puti(task[i]->pid);
            puts("] Process Create Successfully! counter = ");
            puti(task[i]->counter);
#if PREEMPT_ENABLE == 1  // PRIORITY
            puts(" priority = ");
            puti(task[i]->priority);
#endif
            puts("\n");
        }
    }
}

/**
 * @brief called by timer int
 */
void do_timer(void) {
#if PREEMPT_ENABLE == 0  // SJF
    // Print thread info for SJF
    puts("[PID = ");
    puti(current->pid);
    puts("] ");
    puts("Context Calculation: ");
    puts("counter = ");
    puti(current->counter);
    puts("\n");

    // Decrease counter and schedule
    current->counter--;
    if (current->counter <= 0)
        schedule();

#else  // PRIORITY
    current->counter--;
    if (current->counter <= 0)
        current->counter = (current->pid == 0) ? 5 : 8 - current->pid;
    schedule();
#endif
}

/**
 * @brief context switch from current to next
 */
void switch_to(struct task_struct *next) {
    if (current == next)
        return;

    asm("addi sp, sp, 32");  // Restore the stack of switch_to
    CONTEXT_SAVE(current);   // Do context save
    current = next;          // `next` in $s0(-O0), will be overwrite soon
    CONTEXT_LOAD(current);   // This `current` is the argv `next`
    asm("ret");
}

/**
 * @brief dead loop
 */
void dead_loop(void) {
    for (;;)
        ;
}

/**
 * @brief schedule implementation
 */
void schedule(void) {
#if PREEMPT_ENABLE == 0               // SJF
    int i_min_cnt    = LAB_TEST_NUM;  // index of min but not zero counter
    _Bool all_zeroes = 1;
    for (int i = LAB_TEST_NUM; i > 0; i--)
        if (task[i]->state == TASK_RUNNING) {
            if (task[i]->counter > 0 && task[i]->counter < task[i_min_cnt]->counter ||
                task[i_min_cnt]->counter == 0)
                i_min_cnt = i;
            if (task[i]->counter > 0)  // In case of negative cnt
                all_zeroes = 0;
        }
    if (all_zeroes) {
        for (int i = 1; i <= LAB_TEST_NUM; i++)
            if (task[i]->state == TASK_RUNNING) {
                task[i]->counter = rand();

                puts("[PID = ");
                puti(task[i]->pid);
                puts("] Reset counter = ");
                puti(task[i]->counter);
                puts("\n");
            }
        schedule();
    } else {
        puts("[!] Switch from task ");
        puti(current->pid);
        puts(" to task ");
        puti(task[i_min_cnt]->pid);
        puts(", prio: ");
        puti(task[i_min_cnt]->priority);
        puts(", counter: ");
        puti(task[i_min_cnt]->counter);
        puts("\n");

        switch_to(task[i_min_cnt]);
    }

#else  // PRIORITY
    int max_pri = __INT_MAX__, i_min_cnt = 1;
    for (int i = 1; i <= LAB_TEST_NUM; i++)
        if (task[i]->state == TASK_RUNNING)
            if (task[i]->priority < max_pri) {
                i_min_cnt = i;
                max_pri   = task[i]->priority;
            } else if (task[i]->priority == max_pri &&
                       task[i]->counter < task[i_min_cnt]->counter && task[i]->counter > 0)
                i_min_cnt = i;

    // Must be printed here to meet demands, else the printed info is out-dated
    puts("[!] Switch from task ");
    puti(current->pid);
    puts(" to task ");
    puti(task[i_min_cnt]->pid);
    puts(", prio: ");
    puti(task[i_min_cnt]->priority);
    puts(", counter: ");
    puti(task[i_min_cnt]->counter);
    puts("\n");

    // Use another loop to update prio
    for (int i = 1; i <= LAB_TEST_NUM; i++)
        if (task[i]->state == TASK_RUNNING)
            task[i]->priority = rand();

    // Print all threads' info for PRIORITY
    puts("tasks' priority changed\n");
    for (int i = 1; i <= LAB_TEST_NUM; i++)
        if (task[i]->state == TASK_RUNNING) {
            puts("[PID = ");
            puti(task[i]->pid);
            puts("] ");
            puts("counter = ");
            puti(task[i]->counter);
            puts(" priority = ");
            puti(task[i]->priority);
            puts("\n");
        }
    switch_to(task[i_min_cnt]);
#endif
}
```

### sched.h

```c
#ifndef _SCHED_H
#define _SCHED_H

#define TASK_BASE 0x80010000
#define TASK_SIZE (4096)
#define THREAD_OFFSET (5 * 0x08)

#ifndef __ASSEMBLER__

/* task的最大数量 */
#define NR_TASKS 64

#define FIRST_TASK (task[0])
#define LAST_TASK (task[NR_TASKS - 1])

/* 定义task的状态，Lab3中task只需要一种状态。*/
#define TASK_RUNNING 0
#define TASK_INTERRUPTIBLE 1
#define TASK_UNINTERRUPTIBLE 2
#define TASK_ZOMBIE 3
#define TASK_STOPPED 4

// Ensure Mutual Exclusion
#ifdef SJF
#define PREEMPT_ENABLE 0
#else
#ifdef PRIORITY
#define PREEMPT_ENABLE 1
#endif
#endif

#define PREEMPT_DISABLE !PREEMPT_ENABLE

/* Lab3中进程的数量以及每个进程初始的时间片 */
#define LAB_TEST_NUM 4
#define LAB_TEST_COUNTER 5

/* 当前进程 */
extern struct task_struct *current;

/* 进程指针数组 */
extern struct task_struct *task[NR_TASKS];

/* 进程状态段数据结构 */
struct thread_struct {
    unsigned long long ra;
    unsigned long long sp;
    unsigned long long s0;
    unsigned long long s1;
    unsigned long long s2;
    unsigned long long s3;
    unsigned long long s4;
    unsigned long long s5;
    unsigned long long s6;
    unsigned long long s7;
    unsigned long long s8;
    unsigned long long s9;
    unsigned long long s10;
    unsigned long long s11;
};

/* 进程数据结构 */
struct task_struct {
    long state;     // 进程状态 Lab3中进程初始化时置为TASK_RUNNING
    long counter;   // 运行剩余时间
    long priority;  // 运行优先级 1最高 5最低
    long blocked;
    long pid;  // 进程标识符
    // Above Size Cost: 40 bytes

    struct thread_struct thread;  // 该进程状态段
};

/* 进程初始化 创建四个dead_loop进程 */
void task_init(void);

/* 在时钟中断处理中被调用 */
void do_timer(void);

/* 调度程序 */
void schedule(void);

/* 切换当前任务current到下一个任务next */
void switch_to(struct task_struct *next);
void switch_to_asm();

/* 死循环 */
void dead_loop(void);

#define CONTEXT_SAVE(pTask)                           \
    {                                                 \
        asm("sd ra, %0" : : "m"(pTask->thread.ra));   \
        asm("sd sp, %0" : : "m"(pTask->thread.sp));   \
        asm("sd s0, %0" : : "m"(pTask->thread.s0));   \
        asm("sd s1, %0" : : "m"(pTask->thread.s1));   \
        asm("sd s2, %0" : : "m"(pTask->thread.s2));   \
        asm("sd s3, %0" : : "m"(pTask->thread.s3));   \
        asm("sd s4, %0" : : "m"(pTask->thread.s4));   \
        asm("sd s5, %0" : : "m"(pTask->thread.s5));   \
        asm("sd s6, %0" : : "m"(pTask->thread.s6));   \
        asm("sd s7, %0" : : "m"(pTask->thread.s7));   \
        asm("sd s8, %0" : : "m"(pTask->thread.s8));   \
        asm("sd s9, %0" : : "m"(pTask->thread.s9));   \
        asm("sd s10, %0" : : "m"(pTask->thread.s10)); \
        asm("sd s11, %0" : : "m"(pTask->thread.s11)); \
    }

#define CONTEXT_LOAD(pTask)                           \
    {                                                 \
        asm("ld ra, %0" : : "m"(pTask->thread.ra));   \
        asm("ld sp, %0" : : "m"(pTask->thread.sp));   \
        asm("ld s0, %0" : : "m"(pTask->thread.s0));   \
        asm("ld s1, %0" : : "m"(pTask->thread.s1));   \
        asm("ld s2, %0" : : "m"(pTask->thread.s2));   \
        asm("ld s3, %0" : : "m"(pTask->thread.s3));   \
        asm("ld s4, %0" : : "m"(pTask->thread.s4));   \
        asm("ld s5, %0" : : "m"(pTask->thread.s5));   \
        asm("ld s6, %0" : : "m"(pTask->thread.s6));   \
        asm("ld s7, %0" : : "m"(pTask->thread.s7));   \
        asm("ld s8, %0" : : "m"(pTask->thread.s8));   \
        asm("ld s9, %0" : : "m"(pTask->thread.s9));   \
        asm("ld s10, %0" : : "m"(pTask->thread.s10)); \
        asm("ld s11, %0" : : "m"(pTask->thread.s11)); \
    }

#endif

#endif
```

### entry.S

```c
.section .text.entry

.global thread_init
thread_init:
    la t0, dead_loop
    csrw sepc, t0
    sret

.global trap_m
trap_m:
    # Save regs
    addi sp, sp, -264
    sd x1, 256(sp)
    sd x2, 248(sp)
    sd x3, 240(sp)
    sd x4, 232(sp)
    sd x5, 224(sp)
    sd x6, 216(sp)
    sd x7, 208(sp)
    sd x8, 200(sp)
    sd x9, 192(sp)
    sd x10, 184(sp)
    sd x11, 176(sp)
    sd x12, 168(sp)
    sd x13, 160(sp)
    sd x14, 152(sp)
    sd x15, 144(sp)
    sd x16, 136(sp)
    sd x17, 128(sp)
    sd x18, 120(sp)
    sd x19, 112(sp)
    sd x20, 104(sp)
    sd x21, 96(sp)
    sd x22, 88(sp)
    sd x23, 80(sp)
    sd x24, 72(sp)
    sd x25, 64(sp)
    sd x26, 56(sp)
    sd x27, 48(sp)
    sd x28, 40(sp)
    sd x29, 32(sp)
    sd x30, 24(sp)
    sd x31, 16(sp)
    csrr t0, mcause
    sd t0, 8(sp)
    csrr t0, mepc
    sd t0, 0(sp)

    csrr t0, mcause
    srli t1, t0, 63    # t1 = MSB
    andi t0, t0, 0xff  # t0 = code
    beq t1, zero, trap_m_except

    trap_m_int:
        la t1, mcause_MTimer
        beq t0, t1, trap_m_timer
        j trap_m_end

        trap_m_timer:
            # enable mip.stip
            li t0, 0x20   # mip[5]
            csrs mip, t0  # For trap_s

            # clear mie.mtie
            li t0, 0x80
            csrc mie, t0

            j trap_m_end

    trap_m_except:
        la t1, mcause_ecallS
        beq t0, t1, trap_m_ecallS
        j trap_m_except_end

        trap_m_ecallS:
            # !!!!!! clear mip.stip !!!!!!
            li t0, 0x20   # sip[5]
            csrc mip, t0  # Stop from calling trap_s

            # set mtimecmp += time_sep, hardware will clear mip.mtip
            la t0, mtime_addr
            ld t0, 0(t0)    # t0 = mtimecmp
            la t1, time_sep
            add t1, t0, t1  # t1 = mtimecmp+sep
            la t0, mtimecmp_addr
            sd t1, 0(t0)

            # enable mie.mtie
            li t0, 0x80
            csrs mie, t0

            j trap_m_except_end

        trap_m_except_end:
            ld t0, 0(sp)
            addi t0, t0, 4  # mepc += 4
            sd t0, 0(sp)

    trap_m_end:
    # Get regs back
    ld t0, 0(sp)
    csrw mepc, t0
    ld t0, 8(sp)
    csrw mcause, t0
    ld x31, 16(sp)
    ld x30, 24(sp)
    ld x29, 32(sp)
    ld x28, 40(sp)
    ld x27, 48(sp)
    ld x26, 56(sp)
    ld x25, 64(sp)
    ld x24, 72(sp)
    ld x23, 80(sp)
    ld x22, 88(sp)
    ld x21, 96(sp)
    ld x20, 104(sp)
    ld x19, 112(sp)
    ld x18, 120(sp)
    ld x17, 128(sp)
    ld x16, 136(sp)
    ld x15, 144(sp)
    ld x14, 152(sp)
    ld x13, 160(sp)
    ld x12, 168(sp)
    ld x11, 176(sp)
    ld x10, 184(sp)
    ld x9, 192(sp)
    ld x8, 200(sp)
    ld x7, 208(sp)
    ld x6, 216(sp)
    ld x5, 224(sp)
    ld x4, 232(sp)
    ld x3, 240(sp)
    ld x2, 248(sp)
    ld x1, 256(sp)
    addi sp, sp, 264

    mret


.global trap_s
trap_s:
    # Save regs
    addi sp, sp, -264
    sd x1, 256(sp)
    sd x2, 248(sp)
    sd x3, 240(sp)
    sd x4, 232(sp)
    sd x5, 224(sp)
    sd x6, 216(sp)
    sd x7, 208(sp)
    sd x8, 200(sp)
    sd x9, 192(sp)
    sd x10, 184(sp)
    sd x11, 176(sp)
    sd x12, 168(sp)
    sd x13, 160(sp)
    sd x14, 152(sp)
    sd x15, 144(sp)
    sd x16, 136(sp)
    sd x17, 128(sp)
    sd x18, 120(sp)
    sd x19, 112(sp)
    sd x20, 104(sp)
    sd x21, 96(sp)
    sd x22, 88(sp)
    sd x23, 80(sp)
    sd x24, 72(sp)
    sd x25, 64(sp)
    sd x26, 56(sp)
    sd x27, 48(sp)
    sd x28, 40(sp)
    sd x29, 32(sp)
    sd x30, 24(sp)
    sd x31, 16(sp)
    csrr t0, scause
    sd t0, 8(sp)
    csrr t0, sepc
    sd t0, 0(sp)

    csrr t0, scause
    srli t1, t0, 63    # t1 = MSB
    andi t0, t0, 0xff  # t0 = code
    beq t1, zero, trap_s_except

    trap_s_int:
        la t1, scause_STimer
        beq t0, t1, trap_s_timer
        j trap_s_end

        trap_s_timer:
            ecall
            call do_timer

            j trap_s_end

    trap_s_except:

        # No implementation yet
        j trap_s_except_end

        trap_s_except_end:
            ld t0, 0(sp)
            addi t0, t0, 4  # sepc += 4
            sd t0, 0(sp)

    trap_s_end:
    # Get regs back
    ld t0, 0(sp)
    csrw mepc, t0
    ld t0, 8(sp)
    csrw mcause, t0
    ld x31, 16(sp)
    ld x30, 24(sp)
    ld x29, 32(sp)
    ld x28, 40(sp)
    ld x27, 48(sp)
    ld x26, 56(sp)
    ld x25, 64(sp)
    ld x24, 72(sp)
    ld x23, 80(sp)
    ld x22, 88(sp)
    ld x21, 96(sp)
    ld x20, 104(sp)
    ld x19, 112(sp)
    ld x18, 120(sp)
    ld x17, 128(sp)
    ld x16, 136(sp)
    ld x15, 144(sp)
    ld x14, 152(sp)
    ld x13, 160(sp)
    ld x12, 168(sp)
    ld x11, 176(sp)
    ld x10, 184(sp)
    ld x9, 192(sp)
    ld x8, 200(sp)
    ld x7, 208(sp)
    ld x6, 216(sp)
    ld x5, 224(sp)
    ld x4, 232(sp)
    ld x3, 240(sp)
    ld x2, 248(sp)
    ld x1, 256(sp)
    addi sp, sp, 264

    sret
```

