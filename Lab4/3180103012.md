<center><font size=7>《操作系统》Lab4</font></center><br /><div align='right'><font size=4><b>陈希尧</b> 3180103012</font><br /><div align='right'><font size=4>Group17</font></div>

[TOC]

# Lab Basis

## Purpose

结合课堂学习的页式内存管理以及虚拟内存的相关知识，尝试在已有的程序上开启 MMU 并实现页映射，保证之前的进程调度能在虚拟内存下正常运行

## Environment

OS: Ubuntu 18.04.5 LTS on Windows 10 x86_64 (WSL2)

Kernel: 4.19.128-microsoft-standard

Docker version 19.03.13

## Lab Principle

### 3.1 虚拟内存
&emsp;&emsp;MMU（Memory Management Unit），负责`虚拟地址`到`物理地址`的转换。程序在cpu上运行时，他使用的虚拟地址会由MMU进行翻译。为了加速地址翻译的过程，现代cpu都引入了TLB（Translation Lookaside Buffer）。
&emsp;&emsp;分页机制的基本思想是将程序的虚拟地址空间划分为连续的，等长的虚拟页。`虚拟页和物理页的页长固定且相等`（一般情况下为4kb），从而操作系统可以方便的为每个程序构造页表，即虚拟页到物理页的映射关系。
&emsp;&emsp;逻辑上，该机制下的虚拟地址有两个部分组成：`1.虚拟页号`；`2.页内偏移`；在具体的翻译过程中，MMU首先解析得到虚拟地址中的虚拟页号，并通过虚拟页号查找到对应的物理页，最终用该物理页的起始地址加上页内偏移得到最终的物理地址。

### 3.2 RISC-V Virtual-Memory System (Sv39)
#### 3.2.1 RISC-V satp Register（Supervisor Address Translation and Protection Register）
```c
 63      60 59                  44 43                                0
 ---------------------------------------------------------------------
|   MODE   |         ASID         |                PPN                |
 ---------------------------------------------------------------------
```
* MODE 字段的取值如下图：
```c
                             RV 64
     ----------------------------------------------------------
    |  Value  |  Name  |  Description                          |
    |----------------------------------------------------------|
    |    0    | Bare   | No translation or protection          |
    |  1 - 7  | ---    | Reserved for standard use             |
    |    8    | Sv39   | Page-based 39 bit virtual addressing  | <-- 我们使用的mode
    |    9    | Sv48   | Page-based 48 bit virtual addressing  |
    |    10   | Sv57   | Page-based 57 bit virtual addressing  |
    |    11   | Sv64   | Page-based 64 bit virtual addressing  |
    | 12 - 13 | ---    | Reserved for standard use             |
    | 14 - 15 | ---    | Reserved for standard use             |
     -----------------------------------------------------------
```
* ASID (Address Space Identifier) ： 用来区分不同的地址空间，此次实验中直接置0即可。
* PPN (Physical Page Number) ：顶级页表的物理页号，通常 `PPN = physical address >> 12`。
#### 3.2.2 RISC-V Sv39 Virtual Address and Physical Address
```c
     38        30 29        21 20        12 11                           0
     ---------------------------------------------------------------------
    |   VPN[2]   |   VPN[1]   |   VPN[0]   |          page offset         |
     ---------------------------------------------------------------------
                            Sv39 virtual address

```

```c
 55                30 29        21 20        12 11                           0
 -----------------------------------------------------------------------------
|       PPN[2]       |   PPN[1]   |   PPN[0]   |          page offset         |
 -----------------------------------------------------------------------------
                            Sv39 physical address

```
&emsp;&emsp;Sv39模式定义物理地址有56位，虚拟地址有64位。但是，虚拟地址的64位只有39位有效，63-39位在本次实验中（高地址映射）需要为1保证地址有效。Sv39支持三级页表结构，VPN[2-0](Virtual Page Number)分别代表每级页表的`虚拟页号`，PPN[2-0](Physical Page Number)分别代表每级页表的`物理页号`。物理地址和虚拟地址的低12位表示页内偏移（page offset）。


#### 3.2.3 RISC-V Sv39 Page Table Entry
```c
 63      54 53        28 27        19 18        10 9   8 7 6 5 4 3 2 1 0
 -----------------------------------------------------------------------
| Reserved |   PPN[2]   |   PPN[1]   |   PPN[0]   | RSW |D|A|G|U|X|W|R|V| 
 -----------------------------------------------------------------------
                                                     |   | | | | | | | |
                                                     |   | | | | | | | `---- V - Valid
                                                     |   | | | | | | `------ R - Readable
                                                     |   | | | | | `-------- W - Writable
                                                     |   | | | | `---------- X - Executable
                                                     |   | | | `------------ U - User
                                                     |   | | `-------------- G - Global
                                                     |   | `---------------- A - Accessed
                                                     |   `------------------ D - Dirty (0 in page directory)
                                                     `---------------------- Reserved for supervisor software
```

* 0 ～ 9 bit: protection bits
    * V: 有效位，当 V = 0, 访问该PTE会产生Pagefault。
    * R: R = 1 该页可读。
    * W: W = 1 该页可写。
    * X: X = 1 该页可执行。
    * U,G,A,D,RSW本次实验中设置为0即可。

#### 3.2.4 RISC-V Address Translation Details

```text

                              9          9       9        12
            +------------+----------+--------+--------+---------+
        VA  |  Sig Ext   |   VPN[2] | VPN[1] | VPN[0] | Offset  |+-----------------------------+
            +------------+----+-----+----+---+----+---+---------+                              |
                              |          |        |                                            |
  +---------------------------+          |        |                                            v
  |                        +-------------+        +-+                           +-----------+------+
  |  +-----------+------+  |                        |                       PA  |    PPN    |offset|
  |  |           |      |  |  +-----------+------+  |                           +-----------+------+
  |  +-----------+------+  |  |           |      |  |  +-----------+------+           ^
  |  |       ...        |  |  +-----------+------+  |  |           |      |     +-----|-----+------+
  |  +-----------+------+  |  |       ...        |  |  +-----------+------+     |     |     |      | 512
  +->|    PPN    | PROT |  |  +-----------+------+  |  |       ...        |     +-----|-----+------+
     +-----+------------+  +->|    PPN    | PROT |  |  +-----------+------+     |     | ...        | ...
     |     |     |      |     +-----+------------+  +->|    PPN    | PROT |     +-----+-----+------+
+--->+-----|-----+------+     |     |     |      |     +-----+------------+     |    PPN    | PROT |  1
|          +----------------->+-----|-----+------+     |     |     |      |     +------------------+
|    +------------------+           +----------------->+-----|-----+------+     |           |      |  0
+----+       satp       |                                    +----------------->+-----------+------+
     +------------------+                                                             44       10
```

* ==1.从satp的`PPN`中获取根页表的物理地址。==
* 2.通过pagetable中的VPN段,获取PTE。(可以把pagetable看成一个数组，VPN看成下标。PAGE_SIZE为4KB，PTE为64bit(8B), 所以一页中有4KB/8B=512个PTE，而每级VPN刚好有9位，与512个PTE一一对应)。
* 3.检查PTE的 `V bit`，如果不合法，应该产生page fault异常。
* 4.检查PTE的`RWX`bits,如果全部为0，则从PTE中的PPN[2-0]得到的是下一级页表的物理地址，则回到第二步。否则当前为最后一级页表，PPN[2-0]得到的是最终物理页的地址。
* 5.将得到最终的物理页地址，与偏移地址相加，得到最终的物理地址。
(以上为简要的地址翻译过程，完整过程[参考这里](http://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sv32algorithm))

### Virtual Address Translation Process

A virtual address *va* is translated into a physical address *pa* as follows:

1. Let *a* be ${\tt satp}.ppn \times \textrm{PAGESIZE}$, and let *i* = LEVELS − 1. (For Sv32, PAGESIZE=212 and LEVELS=2.)
2. Let *pte* be the value of the PTE at address *a* + *va*.*vpn*[*i*] × PTESIZE. (For Sv32, PTESIZE=4.) If accessing *pte* violates a PMA or PMP check, raise an access-fault exception corresponding to the original access type.
3. If *pte*.*v* = 0, or if *pte*.*r* = 0 and *pte*.*w* = 1, stop and raise a page-fault exception corresponding to the original access type.
4. Otherwise, the PTE is valid. If *pte*.*r* = 1 or *pte*.*x* = 1, go to step 5. Otherwise, this PTE is a pointer to the next level of the page table. Let *i* = *i* − 1. If *i* < 0, stop and raise a page-fault exception corresponding to the original access type. Otherwise, let *a* = *pte*.*ppn* × PAGESIZE and go to step 2.
5. A leaf PTE has been found. Determine if the requested memory access is allowed by the *pte*.*r*, *pte*.*w*, *pte*.*x*, and *pte*.*u* bits, given the current privilege mode and the value of the SUM and MXR fields of the `mstatus` register. If not, stop and raise a page-fault exception corresponding to the original access type.
6. If *i* > 0 and *pte*.*ppn*[*i* − 1 : 0] ≠ 0, this is a misaligned superpage; stop and raise a page-fault exception corresponding to the original access type.
7. If *pte*.*a* = 0, or if the memory access is a store and *pte*.*d* = 0, either raise a page-fault exception corresponding to the original access type, or:
    * Set *pte*.*a* to 1 and, if the memory access is a store, also set *pte*.*d* to 1.
    * If this access violates a PMA or PMP check, raise an access-fault exception corresponding to the original access type.
    * This update and the loading of *pte* in step 2 must be atomic; in particular, no intervening store to the PTE may be perceived to have occurred in-between.
8. The translation is successful. The translated physical address is given as follows:
    * *pa.pgoff* = *va.pgoff*.
    * If *i* > 0, then this is a superpage translation and *pa*.*ppn*[*i* − 1 : 0] = *va*.*vpn*[*i* − 1 : 0].
    * *pa*.*ppn*[LEVELS − 1 : *i*] = *pte*.*ppn*[LEVELS − 1 : *i*].

### Register

#### medeleg

medeleg has a bit position allocated for every synchronous exception shown in Table 3.6 on page 40, with the index of the bit position equal to the value returned in the mcause register (i.e., setting bit 8 allows user-mode environment calls to be delegated to a lower-privilege trap handler).

### Instructions

* csrrw
    * rd, csr, zimm[4:0]
    * t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t
    * 读后写控制状态寄存器 (Control and Status Register Read and Write). I-type, RV32I and RV64I. 记控制状态寄存器 csr 中的值为 t。把寄存器 x[rs1]的值写入 csr，再把 t 写入 x[rd]。
* auipc
    * rd, immediate x[rd] = pc + sext(immediate[31:12] << 12)
    * PC 加立即数 (Add Upper Immediate to PC). U-type, RV32I and RV64I.
    * 把符号位扩展的 20 位（左移 12 位）立即数加到 pc 上，结果写入 x[rd]。

# Lab Steps

## Lab Env

```zsh
$ docker run --name lab4 -it -v /mnt/c/Users/Ulysses/OneDrive/Jun_A/OS/Lab/Lab4/lab4_3180103012:/home/oslab/lab4 -u oslab -w /home/oslab/lab4 oslab:2020 /bin/bash
$ docker start lab4
$ docker exec -it -u oslab -w /home/oslab/lab4 lab4 bash
oslab@10a3bea4265b:~/lab4$ ln -s ~/lab4/.gdbinit ~/.gdbinit
oslab@10a3bea4265b:~/lab4$ sed -i '$a\\nalias gdb=/opt/riscv/bin/riscv64-unknown-linux-gnu-gdb' ~/.bashrc
oslab@10a3bea4265b:~/lab4$ sed -i '$aalias gdb=/opt/riscv/bin/riscv64-unknown-linux-gnu-objdump' ~/.bashrc
```

## Todo

### 4.2 创建映射

- 本次实验使用Sv39分配方案，支持3级页表映射

- 在`vm.c`中编写函数`create_mapping(uint64 *pgtbl, uint64 va, uint64 pa, uint64 sz, int perm)`，用作页表映射的统一接口，其中参数作用如下：
  - `pgtbl`为根页表的基地址
  - `va`, `pa`分别为需要映射的虚拟、物理地址的基地址
  - `sz`为映射的大小
  - `perm`为映射的读写权限
  - 函数中，若需要为页表空间分配物理页，可以自由管理分配`end`之后的物理内存
  
- 在`vm.c`中编写`paging_init`函数，调用`create_mapping`函数将内核起始（0x80000000）的16MB空间映射到高地址（以`0xffffffe000000000`为起始地址），同时也进行等值映射。将必要的硬件地址（如UART）进行等值映射，无偏移



### 4.3 修改head.S

#### 4.3.1 修改系统启动部分代码

- ~~在`_start`开头先设置`satp`寄存器为0，暂时关闭MMU~~
- ~~进入S模式后，在适当位置调用`paging_init`函数进行映射~~
- ~~设置`satp`的值以打开MMU~~
  - ~~注意`satp`中的PPN字段以4KB为单位~~
- ~~设置`stvec`为异常处理函数`trap_s`在**虚拟地址空间下**的地址~~
- ~~设置`sp`的值为**虚拟地址空间**下的`init_stack_top`~~
- ~~跳转到虚拟地址下的`start_kernel`，并在**虚拟地址空间**中执行后续语句与进程调度~~
  - ~~可以先将`start_kernel`的虚拟地址？？？装载在寄存器中，并使用`jr`指令进行跳转~~

#### 4.3.2 修改M模式下异常处理代码

- ~~由于M模式下依然使用物理地址，使用虚拟地址将导致内存访问错误。因此，需要保留一片物理地址区域用于异常处理前保存所有寄存器的值~~
- ~~`mscratch`寄存器是M mode下专用的临时寄存器。通常，它就用于保存M mode下上下文物理空间的地址。lds文件中分配出了1个page的空间用于储存进程上下文，其顶部标记为`stack_top`，请在head.S进入S mode之前的适当位置，将`mscratch`寄存器设置为`stack_top`的物理地址。~~
- ~~在M mode异常处理函数`trap_m`的开头，将`mscratch`与`sp`寄存器的值交换（hint: 使用`csrrw`指令），使用上下文空间作为`trap_m`的栈并保存`x1-x31`寄存器~~
- ~~在`trap_m`返回前将`mscratch`与`sp`寄存器的值重新交换回来~~

### 4.4 修改进程调度相关代码sched.c

#### 4.4.1 修改task_init()调整为虚拟地址

- ~~由于开启了MMU，因此我们需要修改进程相关代码，确保将`task_struct`以及各进程的地址划分到虚拟地址空间。~~ (修改TASK_BASE宏)

#### 4.4.2 在进程调度时打印task_struct地址

- ~~修改`schedule()`函数在调度时的打印输出，要求打印出`current`和`task[next]`的地址以及进程栈顶`sp`的值~~

### 4.5 完成对不同section的保护

- 通过修改调用`create_mapping`时的`perm`参数，修改对不同section所在页属性的设置，完成对不同section的保护
  - 包括：text r-x, rodata r--, other rw-
  - **思考题：如何验证这些属性是否成功被保护**
- ~~在`head.S`中，通过修改`medeleg`寄存器，将instruction/load/store page fault托管到S模式下~~
- ~~修改`strap.c`中的handler，添加对page fault的打印~~

## Code

## Debug

补充一些新的指令：

```
layout src
b sched:73

p /d 0x200bff8
p /d 0x2004000

p /d task[0]->thread.ra
p /d task[1]->thread.ra
p /d task[2]->thread.ra
p /d task[3]->thread.ra
p /d task[4]->thread.ra

p /d task[0]->thread.sp
p /d task[1]->thread.sp
p /d task[2]->thread.sp
p /d task[3]->thread.sp
p /d task[4]->thread.sp

p /d task[0]->counter
p /d task[1]->counter
p /d task[2]->counter
p /d task[3]->counter
p /d task[4]->counter
```

# Lab Results

## Program

### SJF

![](assets/image-20201109132633353.png)

如图，由于随机种子是给定的，因此产生的随机数也是给定的，因此调度结果和实验手册上的完全一样

### PRIORITY

![](assets/image-20201109150554783.png)

同理，和实验手册给出的输出相同

# Problems & Thoughts


## Problems(Debug)

1. 用上一级的PTE中的PPN获得下一级的页表的地址，用下一级的VA中的VPN获得下一级的页表的PTE的index，因此page walk的时候是`LoadPTE(*pte, PAtoPPN((uint64)pgtbl + PAGE_SIZE), 0, 1);`而不是`LoadPTE(*pte, PAtoPPN(pgtbl), 0, 1);`
2. <u>`call paging_init`之前也要设置C的栈环境</u>，给忘了。
3. 不同VPN2的L1页表不能共用地址空间。同理，不同VPN1的L0页表也不能共用地址空间
4. 出现`mcause = 2`(illegal inst)，`mepc = 0x800003ac`(此时MMU已打开，satp=0x8...80008，所以mepc不应该是)，而对应的虚拟地址`0xffffffe0000003ac`中的指令是trap_s中的`ld x31, 16(sp)`
5. scause=15(store PF), sepc=0x800004c8, \*sepc=`sb a4,0(a5)`(`*UART16550A_DR = (unsigned char)(*s);`中的赋值)，说明UART的页表有问题，把16MB改成1B解决
6. scause=12, sepc=0?????
7. PPNtoPTE里面的mask漏了一个0，导致PTE存储出错（但是由于初始值都是0，所以其实没影响）
8. L0的那个PTE的值会变成他的地址（即`*pte_addr == pte_addr`，非常神奇），而且怎么修改都没用。<u>这个错误极其恶心，是因为free list的limit设得太大了（从256MB改到16MB即可）。</u>我也不知道为什么会这样。
    * 稍微改大一点到128MB也可以，怀疑这是qemu的内存分配不够的问题。
    * 对于一次16MB的分配，共需4096个物理页，因此要有8个三级页表，因此二级页表中需要有8个valid的PTE；高位映射和等值映射共需要2个二级页表，16个三级页表；UART映射和另外两个映射无法共享二级页表，独占二级和三级页表各一个；总共需要1+3+17=21个页表，占空间84KB
        * VPN2 = 0x2, 0x1800, 0x0
    * <u>其实把`kalloc_byte()`改成从低向高分配倒也就解决问题了</u>，我觉得就是内存不够。
9. 然后就可以了，但是会有一堆page fault
10. `ffffffe00000011c:  34011173      csrrw  sp,mscratch,sp`，然而`(gdb) x 0x8000011c`得到`0x8000011c:     0x34000000`；同理`ffffffe000000124:  10113023      sd ra,256(sp)`，然而
11. la只能32位，要64位得用li
12. paging init很慢，所以要在init完再打开中断处理，用ecall就行了
13. `mcause=0x02(inst), mepc=0xffffffe000000e22`，这地址都不是整字的，能不错就有鬼了，`0x...e20`是`switch_to`里的指令`sd sp,48(a5)`，查了一下System.map里的switch_to是ffffffe000000ddc，倒也是正常的。
     * 用x指令，`x 0xffffffe000000e20=0, x 0x80000e20=0x000003c0≠sd sp,48(a5)`，说明mapping还是有问题
         * 相关的3c0只有`ffffffe000000208:  03c0006f, j trap_m_except_end`
             * e20=1110 0010 0000, 208=0010 0000 1000，倒也没有关系
14. <u>UART的映射不能只给W权限，要R和W都给。</u>为什么？？
15. `x 0x80000ffc`(dead_loop地址)正常但是`x 0xffffffe000000ffc`却是"Cannot access memory at address 0xffffffe000000ffc"，且satp正常，说明等值映射成功了但是高位映射失败了。而将paging_init改为先高位映射再等值映射，出现了相反的结果。不知道为什么（用于存页表的空间也是够的，函数里也没有什么静态变量）。

      * 先高位再等值：

         ```c
         void paging_init(void) {
             uint64 *rtpg_addr = (uint64 *)kalloc_byte(PAGE_SIZE);
             create_mapping(rtpg_addr, (uint64)UART_ADDR, (uint64)UART_ADDR, PAGE_SIZE,
                 PERM_R | PERM_W);  // 映射UART
             create_mapping(rtpg_addr, MAPPING_BASE_V, MAPPING_BASE_P, MAPPING_SIZE,
                 PERM_R | PERM_W | PERM_X);  // 高位映射
             create_mapping(rtpg_addr, MAPPING_BASE_P, MAPPING_BASE_P, MAPPING_SIZE,
                 PERM_R | PERM_W | PERM_X);  // 等值映射
             puts("\n>> Paging Init Done.\n");
         }/*
         (gdb) x 0xffffffe000000ffc
         0xffffffe000000ffc:     0x0000006f
         (gdb) x 0x80000ffc
         0x80000ffc:     Cannot access memory at address 0x80000ffc
         */
         ```

      * 先等值再高位：

         ```c
         void paging_init(void) {
             uint64 *rtpg_addr = (uint64 *)kalloc_byte(PAGE_SIZE);
             create_mapping(rtpg_addr, (uint64)UART_ADDR, (uint64)UART_ADDR, PAGE_SIZE,
                 PERM_R | PERM_W);  // 映射UART
             create_mapping(rtpg_addr, MAPPING_BASE_P, MAPPING_BASE_P, MAPPING_SIZE,
                 PERM_R | PERM_W | PERM_X);  // 等值映射
             create_mapping(rtpg_addr, MAPPING_BASE_V, MAPPING_BASE_P, MAPPING_SIZE,
                 PERM_R | PERM_W | PERM_X);  // 高位映射
             puts("\n>> Paging Init Done.\n");
         }/*
         (gdb) x 0xffffffe000000ffc
         0xffffffe000000ffc:     Cannot access memory at address 0xffffffe000000ffc
         (gdb) x 0x80000ffc
         0x80000ffc:     0x0000006f
         */
         ```

         

         

## Thoughts

总之就是很烦，c和asm混着写，然后gcc的行为又是不可控的（比如得用反汇编的结果去反推`switch_to`中栈是32字节的、next是用s0存的这样的细节），因此给实验带来了很大的困难。正因如此context switch的实现变得很困难，而算法本身相比起来倒是显得很简单。

# Appendix

## Reference

[assembly - Context saving – how to read segment registers in C and instruction pointer? - Stack Overflow](https://stackoverflow.com/questions/54488861/context-saving-how-to-read-segment-registers-in-c-and-instruction-pointer)

## Code

### sched.c

```c

```

### sched.h

```c

```

### entry.S

```c

```

